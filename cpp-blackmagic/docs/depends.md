# Depends / Inject Guide

This guide is for users of `@inject` and `Depends(...)`.
It focuses on integration, call patterns, runtime override APIs, and troubleshooting.

## 1. Enable inject module

`@inject` metadata is generated by enabling the `inject` preprocess module.

```cmake
set(CPPBM_PREPROCESS_CMAKE
    "${PROJECT_SOURCE_DIR}/cpp-blackmagic/scripts/cmake/preprocess.cmake"
)
include("${CPPBM_PREPROCESS_CMAKE}")

add_executable(my_app src/main.cpp)
CPPBM_ENABLE_DECORATOR(TARGET my_app MODULES inject)
target_link_libraries(my_app PRIVATE cpp-blackmagic)
```

## 2. Minimal working example

```cpp
#include <cppbm/depends.h>

using namespace cpp::blackmagic;

struct Config
{
    const char* env = "prod";
};

Config& DefaultConfigFactory()
{
    static Config cfg{};
    return cfg;
}

decorator(@inject)
const char* ReadEnv(Config& cfg = Depends(DefaultConfigFactory))
{
    return cfg.env;
}
```

## 3. Choosing `Depends(...)`

### 3.1 `Depends()`

```cpp
Config* cfg = Depends();
```

Use when dependency is resolved by type/context without binding to a specific factory key.

### 3.2 `Depends(factory)`

```cpp
Config& cfg = Depends(DefaultConfigFactory);
```

Use when dependency is explicitly tied to a factory function.
This is usually better when you need deterministic override matching.

### 3.3 Cache flag

```cpp
Depends(true);   // default, may reuse existing context slot
Depends(false);  // force fresh resolve
```

## 4. Runtime overrides (context-scoped)

Overrides are **not global**.
They apply to the current inject context only.

### 4.1 Enter an inject context explicitly

```cpp
auto ctx = BeginInjectContext();
```

Use this when you need to inject values before the `@inject` function is entered.

### 4.2 Context-wide override (current context only)

```cpp
Config cfg{ "local" };
auto guard = ScopeOverrideDependency(&cfg, DefaultConfigFactory);
```

### 4.3 Target-specific override

```cpp
Config cfg{ "staging" };
auto guard = ScopeOverrideDependency<&ReadEnv>(&cfg, DefaultConfigFactory);
```

### 4.4 Dynamic target key override

```cpp
const void* key = depends::TargetKeyOf<&ReadEnv>();
auto guard = ScopeOverrideDependencyByTargetKey(key, &cfg, DefaultConfigFactory);
```

All overrides are restored automatically when guard is destroyed.
`ScopeOverrideDependency*` internally binds an inject context scope for the guard lifetime.

## 5. Explicit registration APIs

You can inject values directly into the currently bound context:

```cpp
auto ctx = BeginInjectContext();
InjectDependency(&cfg);
InjectDependency<&ReadEnv>(&cfg, DefaultConfigFactory);
```

Dynamic target-key variant:

```cpp
const void* key = depends::TargetKeyOf<&ReadEnv>();
InjectDependencyByTargetKey(key, &cfg, DefaultConfigFactory);
```

Cleanup APIs (current context only):

```cpp
ClearDependencies();
ClearDependencies<&ReadEnv>();
ClearDependenciesByTargetKey(depends::TargetKeyOf<&ReadEnv>());
```

## 6. Async usage

`cpp::blackmagic::Task<T>` is supported in inject paths.

```cpp
Task<Config&> AsyncFactory();

decorator(@inject)
Task<> Run(Config& cfg = Depends(AsyncFactory));
```

Recommendation:

- validate sync inject behavior first
- then migrate factories to async where needed

## 7. Practical recommendations

- keep default args inject-focused (`Depends(...)` only)
- keep factories as no-arg function pointers
- if one type has multiple providers, prefer `Depends(factory)` to partition keys
- use `ScopeOverrideDependency` in tests for safe rollback
- call `BeginInjectContext()` before manual `InjectDependency*` when not already inside an inject context

## 8. Troubleshooting

### `@inject` does not apply

Check:

1. function has `decorator(@inject)`
2. build enables `CPPBM_ENABLE_DECORATOR(... MODULES inject)`

### Override not taking effect

Common causes:

- no active inject context when calling `InjectDependency*` (returns `false`)
- wrong target key (`&ReadEnv` vs another function)
- wrong factory key (must match `Depends(factory)` declaration)
- cache reuse (`cached=true`) hitting existing slot

### Type mismatch behavior

Matching is type-sensitive. Ensure declaration and override handle types align (`T*`, `T&`, `std::reference_wrapper<T>` semantics differ).

## 9. Reference files

- [depends example](../examples/src/depends_example.cpp)
- [benchmark with sync/async cases](../tests/src/benchmark.cpp)
