# depends.h Guide

## Scope
This document explains `cpp-blackmagic/include/cppbm/depends.h`, including:
- dependency placeholders (`Depends(...)`)
- explicit injection APIs (`InjectDependency...`)
- scoped override APIs (`ScopeOverrideDependency...`)
- `@inject` decorator integration
- failure policy and diagnostics

## Relationship With `decorator(@inject)`
`depends.h` is designed to be used with the generated `@inject` decorator class:

```cpp
decorator(@inject)
void foo(Service* s = Depends());
```

At runtime, the generated injector resolves parameters marked by `Depends(...)`.

Without preprocess (`CPPBM_ENABLE_DECORATOR` + `CPPBM_ENABLE_DEPENDENCY_INJECT`), metadata for default arguments is not generated and injection behavior is incomplete.

## Build Integration

```cmake
include("cpp-blackmagic/scripts/cmake/preprocess.cmake")
CPPBM_ENABLE_DECORATOR(TARGET your_target)
CPPBM_ENABLE_DEPENDENCY_INJECT(TARGET your_target)
```

Optional strict parser mode:

```cmake
set(CPPBM_PREPROCESS_STRICT_PARSER ON)
```

## Public API Surface

### 1) Placeholder Expressions

```cpp
Depends(bool cached = true)
Depends(factory, bool cached = true)
```

Rules:
- `factory` must be zero-arg and return pointer/reference (`T*` or `T&`).
- `cached = true`: allow reusing resolved slot in context chain.
- `cached = false`: force a fresh resolution into current context slot.

### 2) Explicit Injection
Global:

```cpp
InjectDependency(value)
InjectDependency(value, factory)
```

Target-scoped:

```cpp
InjectDependency<&Target>(value)
InjectDependency<&Target>(value, factory)
```

Accepted value categories:
- pointer
- `std::reference_wrapper<T>`

These explicit values are treated as borrowed handles.

### 3) Cleanup and Removal

```cpp
ClearDependencies();            // all targets
ClearDependencies<&Target>();   // one target

RemoveDependency<T>();
RemoveDependency<T>(factory);
RemoveDependency<&Target, T>();
RemoveDependency<&Target, T>(factory);

RemoveDependencyAt(target_key, factory_key, type_index);
```

### 4) Scoped Overrides (RAII)
Global:

```cpp
auto guard = ScopeOverrideDependency(value);
auto guard = ScopeOverrideDependency(value, factory);
```

Target-scoped:

```cpp
auto guard = ScopeOverrideDependency<&Target>(value);
auto guard = ScopeOverrideDependency<&Target>(value, factory);
```

On guard destruction, previous value is restored (or removed if none existed).

## Error Policy
Injection error model is in `cpp-blackmagic/include/cppbm/internal/depends/error.h`.

Types:
- `depends::InjectErrorCode`
- `depends::InjectError`
- `depends::InjectFailPolicy`
- `depends::InjectException`

Configuration:
- `depends::SetInjectFailPolicy(...)`
- `depends::GetInjectFailPolicy()`
- `depends::SetInjectErrorCallback(...)`
- `depends::GetInjectErrorCallback()`

Default behavior is `InjectFailPolicy::Terminate`.

If you need exceptions:

```cpp
cpp::blackmagic::depends::SetInjectFailPolicy(
    cpp::blackmagic::depends::InjectFailPolicy::Throw
);
```

## Resolution Model
The runtime uses per-thread context and slot maps.

High-level order for raw-slot resolution:
1. current/parent context cached slot
2. explicit injected value (`InjectDependency`)
3. default construction/factory result (when allowed)

During `@inject` argument handling:
- placeholder detection decides whether a parameter asks for injection
- default-arg metadata (generated by `inject.py`) provides target/index/type mapping
- explicit injection can override metadata-provided value

Each `@inject` function call creates a fresh local `ContextScope`.

## Lifetime Rules
- Borrowed entries are not deleted by DI context.
- Owned entries are stored with holder and released at context end.
- `Depends(factory)` with pointer-returning factory can produce owned entries.
- Plain pointer/reference explicit injections are borrowed-only by design.

## Minimal Example

```cpp
#include <cppbm/depends.h>

using namespace cpp::blackmagic;

struct Config
{
    const char* name = "default";
};

Config* make_owned()
{
    return new Config{"owned"};
}

decorator(@inject)
void run(Config* c = Depends(make_owned))
{
    // c resolved by @inject pipeline
}

int main()
{
    Config cfg{"override"};
    auto guard = ScopeOverrideDependency<&run>(&cfg);
    run(); // gets override
}
```

## Operational Notes and Limits
- `Depends(...)` marker protocol relies on preprocess-generated metadata for robust resolution.
- For explicit injection APIs, only pointer/reference-wrapper handles are accepted.
- Keep target function signatures stable after preprocess wiring; significant signature drift can invalidate metadata assumptions.
- Prefer strict parser mode for production CI to avoid regex fallback surprises.
