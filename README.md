# cpp-blackmagic

`cpp-blackmagic` is a C++20 toolkit focused on practical call-site instrumentation:

- function decorators (`decorator(@xxx)`)
- dependency injection (`decorator(@inject)` + `Depends(...)`)

If you want logging, tracing, route registration, or runtime dependency overrides without rewriting business function signatures, this project is built for that workflow.

## What You Actually Use

- Add a decorator to a function: `decorator(@logger)`
- Use expression-based decorators: `decorator(@router.get("/health"))`
- Inject default dependencies: `decorator(@inject)` + `Depends(...)`
- Override dependencies in tests: `ScopeOverrideDependency(...)`

## Quick Start

### 1) Requirements

- C++20 compiler
- CMake >= 3.10
- Python 3
- Python packages: `tree_sitter`, `tree_sitter_cpp`

```bash
pip install tree_sitter tree_sitter_cpp
```

### 2) Enable preprocessing in CMake

```cmake
set(CPPBM_PREPROCESS_CMAKE
    "${PROJECT_SOURCE_DIR}/cpp-blackmagic/scripts/cmake/preprocess.cmake"
)
include("${CPPBM_PREPROCESS_CMAKE}")

add_executable(my_app src/main.cpp)

# Decorator only
CPPBM_ENABLE_DECORATOR(TARGET my_app)

# For @inject, enable module "inject"
# CPPBM_ENABLE_DECORATOR(TARGET my_app MODULES inject)

target_link_libraries(my_app PRIVATE cpp-blackmagic)
```

### 3) Enable preprocessing in MSBuild (`.vcxproj`)

Import `preprocess.targets` only:

```xml
<ImportGroup Label="ExtensionTargets">
  <Import Project="$(MSBuildProjectDirectory)\thirdparty\scripts\msbuild\preprocess.targets"
          Condition="Exists('$(MSBuildProjectDirectory)\thirdparty\scripts\msbuild\preprocess.targets')" />
</ImportGroup>
```

`preprocess.targets` will auto-import `preprocess.props` when available.

### 4) Minimal decorator example

```cpp
#include <cppbm/decorator.h>

using namespace cpp::blackmagic;

template <auto Target>
class LoggerDecorator;

template <typename R, typename... Args, R(*Target)(Args...)>
class LoggerDecorator<Target> : public FunctionDecorator<Target>
{
public:
    bool BeforeCall(Args&... /*args*/) override
    {
        // before logic
        return true;
    }

    void AfterCall(R& /*result*/) override
    {
        // after logic
    }
};

CPPBM_DECORATOR_BINDER(LoggerDecorator, logger);

decorator(@logger)
int add(int a, int b)
{
    return a + b;
}
```

When you need per-call decorator state, use `hook::CallContext&` overloads plus `ContextSize()`.
See `cpp-blackmagic/docs/decorator.md` for the full `CallContext` pattern.

### 5) Minimal inject example

```cpp
#include <cppbm/depends.h>

using namespace cpp::blackmagic;

struct Config { const char* env = "prod"; };

Config& DefaultConfigFactory()
{
    static Config cfg{};
    return cfg;
}

decorator(@inject)
const char* ReadEnv(Config& cfg = Depends(DefaultConfigFactory))
{
    return cfg.env;
}
```

## Docs

- [Decorator Guide](cpp-blackmagic/docs/decorator.md)
- [Depends/Inject Guide](cpp-blackmagic/docs/depends.md)
- [Preprocess Integration Guide](cpp-blackmagic/docs/preprocess.md)

## Examples

- [Decorator example entry](cpp-blackmagic/examples/src/decorator/main.cpp)
- [Decorator member-function case](cpp-blackmagic/examples/src/decorator/case_member.cpp)
- [Depends/Inject example](cpp-blackmagic/examples/src/depends_example.cpp)

## Common Issues

### `decorator(@xxx)` compiles but does nothing

`decorator(...)` is a marker macro. Real binding is generated by preprocess scripts. Make sure preprocessing is enabled for your target.

### `@inject` does not resolve defaults

Check both:

1. Target function has `decorator(@inject)`
2. Build enables `MODULES inject`

### How to override dependencies in tests

Use RAII override guards:

```cpp
auto guard = ScopeOverrideDependency<&Target>(mock_ptr, Factory);
```

Value is restored automatically when guard goes out of scope.
